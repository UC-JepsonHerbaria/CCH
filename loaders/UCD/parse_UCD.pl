use Geo::Coordinates::UTM;

use lib '/Users/davidbaxter/DATA';
use CCH;
$today=`date "+%Y-%m-%d"`;
chomp($today);
($today_y,$today_m,$today_d)=split(/-/,$today);
&load_noauth_name;

my $m_to_f="3.2808";
my $feet_to_meters="3.2808";

open(COORDS_LOG, ">coords.log") || die;



#Annotations file is generated by parse_annos.pl into anno_table.txt
#Process the Annotations file
#Annotations need to be sorted by the orig_det column ("-1" at top) so that they will print out correctly
#this can be done with the command ":sort n" (numeric sort) in vi. 
open(IN,"anno_table.txt") || die ("no anno_table.txt Did you run parse_davis.sh?");
while(<IN>){
	$det_string="";
	chomp;

	#UCD42533	Potentilla glandulosa Lindl. ssp. nevadensis (S. Watson) Keck; ; 2004; Original determination	-1
	($orig_det,
	$anno_id,
	$det_string) = split(/\t/);

	$ANNO{$anno_id}.="Annotation: $det_string\n";
}
close(IN);



#Process the main file
$/="<qryUCConsortium>";

open(ERR, ">Davis_problems") || die;
open(OUT, ">UCD.out") || die;
open(IN,"UCConsortium.xml") || die;

warn "processing XML\n";
# 73 </Locality
# 44679 </UCConsortium
# 1 </dataroot
# 1 <?xml version="1.0" encoding="UTF-8"?
# 23964 <Accession
# 41816 <Authority
# 4141 <InfraspecificAuthority
# 6204 <InfraspecificName
# 1103 <LatLongAccuracy
# 5775 <LatLongDatum
# 9697 <LatitudeDecimal
# 9697 <LatitudeDegree
# 9690 <LatitudeDirection
# 9684 <LatitudeMinutes
# 7974 <LatitudeSeconds
# 44546 <Locality
# 9697 <LongitudeDecimal
# 9699 <LongitudeDegree
# 9695 <LongitudeDirection
# 9688 <LongitudeMinutes
# 8124 <LongitudeSeconds
# 10907 <MoreCollectors
# 4014 <Prefix
# 6171 <Rank
# 42612 <SpecificEpithet
# 1783 <Suffix
# 4920 <TownshipAndRange
# 53 <TypeStatus
# 44679 <UCConsortium
# 4475 <USGSQuadrangle
# 3459 <USGSQuadrangleScale
# 3562 <UTMZone
# 1 <dataroot xmlns:od="urn:schemas-microsoft-com:officedata"
# 3585 <easting
# 3585 <northing

Record: while(<IN>){
#warn "$.  " unless $.%10000;
#	($err_line=$_)=~s/\n/\t/g;
	$hybrid_annotation=$source=$combined_collector=$assignor=$genus=$LatitudeDirection=$LongitudeDirection=$date= $collnum= $coll_num_prefix= $coll_num_suffix= $name= $id= $county= $locality= $Unified_TRS= $elevation= $collector= $other_coll= $ecology= $color= $lat= $long= $decimal_lat= $decimal_long=$zone=$notes="";
	s/&apos;/'/g;
	s/&quot;/"/g;
	s/&amp;/&/g;
s/\cM/ /g;
#Replace any tabs with spaces
s/\\t/ /g;

s/\xe2\x80\x9c/"/g;
s/\xe2\x80\x9d/"/g;
s/\xe2\x89\x88/&#8776;/g;
s/\xe2\x80\x99/'/g;

s/\xc2\xa1/&iexcl;/g;
s/\xc2\xae/&reg;/g;
s/\xc2\xb0/&deg;/g;
s/\xc2\xb1/&plusmn;/g;
s/\xc2\xbd/1\/2/g;
s/\xc3\x81/&Aacute;/g;
s/\xc3\xa0/&agrave;/g;
s/\xc3\xa2/&acirc;/g;
s/\xc3\xa4/&auml;/g;
s/\xc3\xa7/&ccedil;/g;
s/\xc3\xab/&euml;/g;
s/\xc3\xad/&iacute;/g;
s/\xc3\xb3/&oacute;/g;
s/\xc3\xb1/&ntilde;/g;
s/\xc3\x97/&times;/g;
s/\xc3\xa1/&aacute;/g;
s/\xc3\xa8/&egrave;/g;
s/\xc3\xa9/&eacute;/g;
s/\xc3\xb6/&ouml;/g;
s/\xc3\xb7/&divide;/g;
s/\xc3\xbc/&uuml;/g;
s/\xcb\x9a/&deg;/g;




	($id)=m/<HerbID>(.*)</;
	$id="UCD$id";
	if($seen{$id}++){
		$genus_tag="AGenus";
		$species_tag="ASpecificEpithet";
		$infra_tag="AInfraspecificName";
		#warn "Duplicate number: $id<\n";
		print ERR<<EOP;

Duplicate accession number $id
EOP
		#next;
	}

	unless(m/<GeoSecondaryDivision> *California *</){
		($state)=m/<GeoSecondaryDivision>(.*)</;
		print ERR "Non-California record, skipped: $state $id\n";
		next;
	}
	unless(m/<HerbID>\d+<\/HerbID>/){
		print ERR "No Id, skipped $id\n";
		next;
	}
#We are including cultivated plants now, so this is commented out!
#	if(m/<Locality>.*Arboretum.*<\/Locality>/s){
#		print ERR "Arboretum plant: skipped $id\n";
#		next;
#	}



#####PARSE NAME
if(m|<Genus>(.+)</Genus>|s){
	$name=$1;
	$name=~s/ *$//;
	$genus=$name;
	$genus=~s/^ *//;
	unless($genus){
		print ERR "No generic name, skipped: $id\n";
		next;
	}
}
else{
	print ERR "No generic name, skipped: $id\n";
	next Record;
}
	
if(m|<SpecificEpithet>(.+)</SpecificEpithet>|s){
	$name.=" " . lc($1);

	#I put these inside the "if Specific Epithet" so that the infra isn't printed when it only pertains to the hybrid names (they will be represented in the annotations table)
	if(m|<Rank>(.+)</Rank>|s){
		$rank=$1;
		$rank=~s/ *$//;
		$rank=~s/^ *//;
		$rank=~s/ssp\.?/subsp./;
		$rank=~s/form.*/f./;
		$rank.=".";
		$rank=~s/\.\././;
		$name.=" $rank";
	}
	elsif(m|<InfraspecificName>(.+)</InfraspecificName>|s){ #somethings there is an infra epithet but no rank. This inserts subsp as a default
		&log("Infraspecific epithet but no rank: trying subsp.\t$id");
		$name.=" subsp.";
		warn "$id infra rank added: $name\n";
	}
	
	if(m|<InfraspecificName>(.+)</InfraspecificName>|s){
		$name.=" " . lc($1);
	}
}
elsif(m|<hybridspp1>(.+)</hybridspp1>|s){
	$name.=" " . lc($1);
}
elsif(m|<hybridspp2>(.+)</hybridspp2>|s){
	$name.=" " . lc($1);

	#I put these inside the "if Specific Epithet" so that the infra isn't printed when it only pertains to the hybrid names (they will be represented in the annotations table)
	if(m|<Rank>(.+)</Rank>|s){
		$rank=$1;
		$rank=~s/ *$//;
		$rank=~s/^ *//;
		$rank=~s/ssp\.?/subsp./;
		$rank=~s/form.*/f./;
		$rank.=".";
		$rank=~s/\.\././;
		$name.=" $rank";
	}
	elsif(m|<InfraspecificName>(.+)</InfraspecificName>|s){ #somethings there is an infra epithet but no rank. This inserts subsp as a default
		&log("Infraspecific epithet but no rank: trying subsp.\t$id");
		$name.=" subsp.";
	}
	
	if(m|<InfraspecificName>(.+)</InfraspecificName>|s){
		$name.=" " . lc($1);
	}
}
	
#print "\nTEST $name<\n";
$name=ucfirst(lc($name));
$name=~s/^X ([a-z])/X \u$1/;
#$name=~s/'//g;
$name=~s/`//g;
$name=~s/&times;/X /;
$name=~s/\(*\?\)*//g;
$name=~s/ *$//;
$name=~s/  +/ /g;
$name=~s/ spp\./ subsp./;
$name=~s/ssp\./subsp./;
$name=~s/ ssp / subsp. /;
$name=~s/ subsp / subsp. /;
$name=~s/ var / var. /;
$name=~s/ var. $//;
$name=~s/ sp\..*//;
$name=~s/ sp .*//;
$name=~s/ [Uu]ndet.*//;
$name=~s/ x / X /;
$name=~s/ × / X /;
$name=~s/ *$//;

if ($name=~/ cultivar/){
	&log("Cultivar removed from $name");
	$name=~s/ cultivar.*//;
}

#print "TEST $name<\n";

if($name=~s/ (aff\.|cf\.|indet\.)//){
                 $hybrid_annotation=$name;
          #       warn "$1 deleted from $name\n";
                 &log("$1 deleted $name\t$id");
             }
if($name=~s/([A-Z][a-z-]+ [a-z-]+) [Xx×] /$1 X /){
                 $hybrid_annotation=$name;
                 #warn "$1 from $name\n";
                 &log("hybrid formula: $1 from $name\t$id");
                 $name=$1;
             }
	     else{
                 $hybrid_annotation="";
	     }


if($exclude{$genus}){
	&log("Excluded, not a vascular plant: $name");
	next Record;
}

%infra=( 'var.','subsp.','subsp.','var.');

if($alter{$name}){
        &log("$name altered to $alter{$name}");
                $name=$alter{$name};
}

$name=&strip_name($name);

if($TID{$name}){
        $name=$name;
}
elsif($alter{$name}){
        &log("$name altered to $alter{$name}");
                $name=$alter{$name};
}
elsif($name=~s/(var\.|subsp\.)/$infra{$1}/){
        if($TID{$name}){
                &log("$name not in SMASCH  altered to $name");
                $name=$name;
        }
        elsif($alter{$name}){
                &log("$name not in smasch  altered to $alter{$name}");
                $name=$alter{$name};
        }
	else{
        	&log ("skipping: $name is not yet in the master list: $name skipped");
		next Record;
	}
}
else{
        &log ("skipping: $name is not yet in the master list: $name skipped");
	next Record;
}


$name{$name}++;
#######END NAME PARSING
##########################



	if(m|<Elevation2>(.+)</Elevation2>|s){
		$elevation=$1;
		if(m|<Elevation>(.+)</Elevation>|s){
			$elevation = "$1 - $elevation";
		}
		if(m|<ElevationUnits>(.*)</ElevationUnits>|s){
			$elevation.=" $1";
			#$elevation=~s/\. *//;
		}
	}
	elsif(m|<Elevation>(.+)</Elevation>|s){
		$elevation=$1;
		if(m|<ElevationUnits>(.*)</ElevationUnits>|s){
			$elevation.=" $1";
			#$elevation=~s/\. *//;
		}
	}
	elsif(s/ *(Elevation|Elev\.) (\d+) *'//i){
		$elevation="$2 ft";
	}
	elsif(s/ *(Elevation|Elev\.) (\d+) *ft\.?//i){
		$elevation="$2 ft";
	}
	elsif(s/ *(Elevation|Elev\.) (\d+) *feet\.?//i){
		$elevation="$2 ft";
	}
	elsif(s/ *(Elevation|Elev\.) (\d+) *m\.?//i){
		$elevation="$2 m";
	}
	else{
		$elevation="";
	}
	if(($locality)=m|<Locality>(.+)</Locality>|s){
		$locality=~s/<!\[CDATA\[(.*)\]\]>/$1/;
		$locality=~s/CALIFORNIA[:,.] .*(CO|County)[.:;,]+//i;
		$locality=~s/^ *[,.:;] *//;
		$locality=~s/[,.:; ]+$//;
		#print "$locality\n";
	}
	else{
		$locality="";
	}
#<CorrectedDate>1974-04-22T00:00:00</CorrectedDate>
	if(($year,$month,$day)=m|<CorrectedDate>(\d\d\d\d)-(\d\d)-(\d\d).*</CorrectedDate>|s){
$date = "$month $day $year";
#print "picking up Cdate ";
}
	else{
	if(m|<Date>(.*)</Date>|s){
		$date=$1;
		$date=~s/<!\[CDATA\[ *(.*)\]\]>/$1/;
#Note ells in date
		$date=~s/l(9\d\d)/1$1/;
		if($date=~m/^\d+[- ]+[A-Za-z.]+[ -]+\d\d\d\d/){
			($day,$month,$year)=split(/[- .]+/,$date);
			$month=substr($month,0,3);
			unless($month=~/[A-Za-z][a-z][a-z]/){
				#warn "1 Date problem:  $date\n";
			}
		}
		elsif($date=~m/([A-Za-z.]+) +(\d+),? +(\d\d\d\d)/){
			$month=$1; $day=$2; $year=$3;
		}
		elsif($date=~m/^([A-Za-z.,]+) +(\d\d\d\d)/){
			$month=$1; $year=$2; $day="";
		}
		elsif($date=~m|\d+/\d+/\d\d\d\d|){
			#date is OK;
		}
		elsif($date=~m|^(\d\d\d\d)\??|){
			$date=$1;
		}
		elsif($date=~m|(\d+)[/ ]*([A-Za-z,.]+)[/ ]*(\d\d\d\d)|){
			$day=$1; $month=$2;$year=$3;
		}
		elsif($date=~m|(\d+)[/ ]*([A-Za-z,.]+)[/ ]*([1-9]\d)$|){
			$day=$1; $month=$2;$year="19$3";
			print ERR "Y2K problem, $date = $year?: $id\n";
		}
		elsif($date=~m|(\d+)/(\d+)/([1-9]\d)$|){
			$day=$1; $month=$2;$year="19$3";
			print ERR "Y2K problem, $date = $year?: $id\n";
		}
		elsif($date=~m|(\d+)[/ ]*([A-Za-z,.]+)[/ ]*(0\d)$|){
				$day=$1; $month=$2;$year="20$3";
		print ERR "Y2K problem, $date = $year?: $id\n";
		}
		elsif($date=~m|(\d+)/(\d+)/(0\d)$|){
				$day=$1; $month=$2;$year="20$3";
		print ERR "Y2K problem, $date = $year?: $id\n";
		}
		elsif($date=~m|(\d+-\d+)[- ]+([A-Za-z.])+[ -]+(\d\d\d\d)|){
				$day=$1; $month=$2;$year=$3;
			}
		elsif($date=~m|19(\d)_\?|){
			$year="19${1}0s";
			}
		elsif($date=~m|19__\?|){
			$year="1900s";
			}
		elsif($date=~m|([A-Z][a-z.]+) *- *([A-Z][a-z]+) (\d\d\d\d)|){
			$day=""; $month="$2-$3";$year=$3;
		}
		else{
			print ERR "Fall thru Date problem: $date made null $id\n" unless $date=~/unknown/i;
			$date="";
		}
$day="" if $day eq "00";
			$month=substr($month,0,3);
$date = "$month $day $year";
$date=~s/  */ /g;
	}
	}
	if(m|<Ecology>(.*)</Ecology>|s){
		$ecology=$1;
		$ecology=~s/<!\[CDATA\[(.*)\]\]>/$1/;
	}
	else{
		$ecology=""
	}
	if(m|<Habitat>(.*)</Habitat>|s){
		$habitat=$1;
	}
	else{
		$habitat=""
	}
	if(m|<Collector>(.*)</Collector>|s){
		$collector=$1;
		$collector=~s/<!\[CDATA\[(.*)\]\]>/$1/;
		$collector=~s/([A-Z]\.) (and|&) ([A-Z]\.) ([A-Z][a-z]+)/$1 $4, $3 $4/;
		$collector=~s/([A-Z]\.)([A-Z][a-z])/$1 $2/g;
		$collector=~s/\./. /g;
		$collector=~s/ +,/,/;
		$collector=~s/  +/ /g;
		$collector=~s/ *$//;
		$collector=~s/^ *//;
		$assignor=$collector;
		$assignor=&modify_coll_davis($assignor);
		$need_coll{$assignor}++ unless $coll_comm{$assignor};
		if(m|<MoreCollectors>(.*)</MoreCollectors>|s){
			$other_coll=$1;
			$other_coll=~s/<!\[CDATA\[(.*)\]\]>/$1/i;
			$other_coll=~s/^ *and //;
			$other_coll=~s/^ *[Ww]ith //;
			$combined_collector= "$collector, $other_coll";
			$collector=$assignor;
			$combined_collector=~s/,? (with|&|and) /, /g;
			$combined_collector=~s/ (with|&|and) */, /g;
			$combined_collector=~s/\./. /g;
			$combined_collector=~s/ +,/,/;
			$combined_collector=~s/  +/ /g;
			$combined_collector=~s/ *$//;
			$combined_collector=~s/^ *//;
			$combined_collector=&modify_coll_davis($combined_collector);
			$need_coll{$combined_collector}++ unless $coll_comm{$combined_collector};
		}
		else{
			$combined_collector="";
		}
	}
	if(m|<CollectionNumber>(.*)</CollectionNumber>|s){
		$collnum=$1;
		$collnum=~s/<!\[CDATA\[ *(.*)\]\]>/$1/;
		if(m|<Prefix>(.*)</Prefix>|s){
			$coll_num_prefix=$1;
		}
		if(m|<Suffix>(.*)</Suffix>|s){
			$coll_num_suffix=$1;
		}
	}
	else{
		#warn "NO CNUM$_\n";
	}
if(m/<UTMZone>/){
	$zone=$easting=$northing="";
	if(m/<UTMZone>(\d+).*/){
		$zone="${1}N";
		#print "1 $zone $&\n";
	}
	elsif(m/<UTMZone>Zone (\d+).*/){
		$zone="${1}N";
		#print "2 $zone $&\n";
	}
	if (m/<easting>(\d+)/){
		$easting=$1;
	}
	if (m/<northing>(\d+)/){
		$northing=$1;
	}
	if(m/Datum>(.*)</){
		$datum=$1;
		if($datum=~/WGS.*84/){
			$ellipsoid=23;
		}
		elsif($datum=~/NAD.*83/i){
			$ellipsoid=23;
		}
		elsif($datum=~/NAD.*27/){
			$ellipsoid=5;
		}
		else {
			print COORDS_LOG "$datum\n";
		}
	}
	else{
		$datum="";
		$zone="";
	}
}
if(m|<LongitudeDegree>(.+)</LongitudeDegree>|s){
	$long=$1;
	$long=~s/^ //;
	if(m|<LongitudeMinutes>(.+)</LongitudeMinutes>|s){
		$minutes=$1;
		$minutes="0$minutes" if $minutes=~/^.$/;
		$long.=" $minutes";
		if(m|<LongitudeSeconds>(.+)</LongitudeSeconds>|s){
			$long.=" $1";
		}
	}
	elsif(m|<LongitudeSeconds>(.+)</LongitudeSeconds>|s){
		$long.=" 00 $1";
		}
($LongitudeDirection)=m|<LongitudeDirection>(.*)</LongitudeDirection>|;
$LongitudeDirection="W" unless $LongitudeDirection;
$long .= $LongitudeDirection;
$long=~s/  */ /g;
print  COORDS_LOG "L: $long\n";
}
else{
$long="";
}
if(m|Datum>(.*)</.*Datum>|s){
$datum=$1;
}
else{
$datum="";
}

if(m|<LatitudeDegree>(.+)</LatitudeDegree>|s){
	$lat=$1;
	$lat=~s/^ //;
	if(m|<LatitudeMinutes>(.+)</LatitudeMinutes>|s){
		$minutes=$1;
		$minutes="0$minutes" if $minutes=~/^.$/;
		$lat.=" $minutes";
		if(m|<LatitudeSeconds>(.+)</LatitudeSeconds>|s){
			$lat.=" $1";
		}
	}
	elsif(m|<LatitudeSeconds>(.+)</LatitudeSeconds>|s){
		$lat.=" 00 $1";
		}
($LatitudeDirection)=m|<LatitudeDirection>(.*)</LatitudeDirection>|;
$LatitudeDirection="N" unless $Latitude_Direction;
$lat .= $LatitudeDirection;
$lat=~s/  */ /g;
print COORDS_LOG "LT: $lat\n";
}
else{
$lat="";
}


if(m|<LatitudeDecimal>([\d.]+)</LatitudeDecimal>|){
$decimal_lat=$1;
}
else{
$decimal_lat="";
}
if(m|<LongitudeDecimal>([\d.-]+)</LongitudeDecimal>|){
$decimal_long=$1;
		print COORDS_LOG " LD $decimal_lat, $decimal_long\n";
}
else{
$decimal_long="";
}
	
unless ($decimal_lat && $decimal_long){
	if($zone){
		($decimal_lat,$decimal_long)=utm_to_latlon($ellipsoid,$zone,$easting,$northing);
		print COORDS_LOG " UTM $decimal_lat, $decimal_long\n";
$source="UTM conversion";
	}
}

if(($decimal_lat=~/\d/  || $decimal_long=~/\d/)){
	$decimal_long="-$decimal_long" if $decimal_long > 0;
	if($decimal_lat > 42.1 || $decimal_lat < 30.0 || $decimal_long > -114 || $decimal_long < -124.5){
		if($zone){
		print ERR "coordinates set to null, Outside California: $id: UTM is $zone $easting $northing --> $decimal_lat $decimal_long\n";
		}
		else{
		print ERR "coordinates set to null, Outside California: D_lat is $decimal_lat D_long is $decimal_long lat is $lat long is $long\n";
		}
$decimal_lat =$decimal_long="";
}   
}  





if(m|<TownshipAndRange>T.*(\d+).*(N).*R.*(\d+).*(E).*Sect.*(\d+)</TownshipAndRange>|s){
$Unified_TRS="$1$2$3$4$5";
}
else{
$Unified_TRS="";
}
if(m/<GeoTertiaryDivision>(.+)</){
$county=$1;
$county=~s/ *County//i;
	}
else{
$county="unknown";
}
foreach($county){
	s/San Bernadino/San Bernardino/;
	s/San Bernidino/San Bernardino/;
	s/San Beradino/San Bernardino/;
	s/San Berardino/San Bernardino/;
	s/Santa Barabara/Santa Barbara/;
	s/Toulomne/Tuolumne/;
	s/Tuolomne/Tuolumne/;
	s/Los Angelos/Los Angeles/;
	s/Monterrey/Monterey/;
	s/Montery/Monterey/;
	s/Santo Cruz/Santa Cruz/;
	s/Calveras/Calaveras/;
	s/Calaveris/Calaveras/;
s/SISKYOU/Siskiyou/;
	s/Yolo Grasslands Park/Yolo/;
	s/ and.*//;
	s/^S\. ?E\. ?//;
	s/^Western //;
	s/El ?[dD]or[ao]do/El Dorado/;
	s/Mododc/Modoc/;
	s/Solona/Solano/;
	s/Glen$/Glenn/;
	s/UC Davis Campus/Yolo/;
	s/Armador/Amador/;
	s/Humbolt/Humboldt/;
	s/Mendicino/Mendocino/;
	s/-.*//;
	s/ or .*//;
	s/ Co\.?$//;
	s/\?//;
	s| */.*||;
	s/ ?- .*//;
	s/ *\.$//;
	s/^ *$/unknown/;
	s/^ *//;
	s/ *$//;
unless(m/^(Alameda|Alpine|Amador|Butte|Calaveras|Colusa|Contra Costa|Del Norte|El Dorado|Fresno|Glenn|Humboldt|Imperial|Inyo|Kern|Kings|Lake|Lassen|Los Angeles|Madera|Marin|Mariposa|Mendocino|Merced|Modoc|Mono|Monterey|Napa|Nevada|Orange|Placer|Plumas|Riverside|Sacramento|San Benito|San Bernardino|San Diego|San Francisco|San Joaquin|San Luis Obispo|San Mateo|Santa Barbara|Santa Clara|Santa Cruz|Shasta|Sierra|Siskiyou|Solano|Sonoma|Stanislaus|Sutter|Tehama|Trinity|Tulare|Tuolumne|Unknown|Ventura|Yolo|Yuba|Ensenada|Mexicali|Rosarito, Playas de|Tecate|Tijuana|unknown)/i){
		print ERR <<EOP;
skipped: Unknown California county, not corrected; $_ $id
EOP
next Record;
	}
	}
	unless ($county=~/[Uu]nknown/){
	$elev_test=$elevation;
		$elev_test=~s/.*- *//;
		$elev_test=~s/ *\(.*//;
		$elev_test=~s/ca\.? *//;
		if($elev_test=~s/ (meters?|m)//i){
			$metric="(${elev_test} m)";
			$elev_test=$elev_test * $m_to_f;
			$elev_test= " feet";
		}
		else{
			$metric="";
		}
		if($elev_test=~s/ +(ft|feet)//i){

			if($elev_test > $max_elev{$county}){
				print ERR "ELEV: $id\t$county\t $elevation $metric greater than max: $max_elev{$county} discrepancy=", $elev_test-$max_elev{$county},"\n";
			}
		}
	}

if($ecology=~s/[.,;] *([Ff]lowers [^.]+)\././){
$color=$1;
}
else{
$color="";
}
$decimal_lat="" unless $decimal_long;
$decimal_long="" unless $decimal_lat;
$long=~s/E/W/;



#####DET BY used to be put in an annotation
#####but now that they're giving annotation records, I've taken $annotation out of here and the printout
if(m/<DeterminedBy>(.*)<\/DeterminedBy>/){
$annotation="$name; $1";
}
else{
$annotation="";
}

#<LatLongAccuracy>5 pdop</LatLongAccuracy> changed to \s* to take care of erroneous tabbed white space in some records between number and unit
if(m|<LatLongAccuracy>\s*([0-9.]+)\s*(pdop)</LatLongAccuracy>|){
#warn "$&\n";
$extent=int($1*20);
$ExtUnits="m";
$notes="GPS accuracy: $1 $2"
}
#<LatLongAccuracy>100 ft.</LatLongAccuracy>
elsif(m|<LatLongAccuracy>\s*([0-9.]+)\s*([^<]+)</LatLongAccuracy>|){
#if(m|<LatLongAccuracy>|){
#warn "$&\n";
$extent=$1;
$ExtUnits = lc($2);
}
else{
$extent="";
$ExtUnits = "";
}

if(m!<LatLongDatum>(.+)</LatLongDatum>!){
$datum=$1;
}
else{
$datum="";
}
if(m!<USGSQuadrangle>(.+)</USGSQuadrangle>!){
	$quad="USGS quad $1";
	if(m!<USGSQuadrangleScale>(.+)</USGSQuadrangleScale>!){
		$quad.= " $1";
	}
}
else{
$quad="";
}
foreach(
$annotation,
$date,
$collnum,
$coll_num_prefix,
$coll_num_suffix,
$name,
$id,
$county,
$locality,
$Unified_TRS,
$elevation,
$assignor,
$other_coll,
$combined_collector,
$ecology,
$color,
$lat,
$long,
$decimal_lat,
$decimal_long,
$quad,
){
s/\n/ /g;
s/[ 	][ 	]*/ /g;
}
foreach($datum){
	s/NAD 1927/NAD27/;
	s/NAD 1983/NAD83/;
	s/WGS 1984/WGS84/;
}

print OUT <<EOP;
Date: $date
CNUM: $collnum
CNUM_prefix: $coll_num_prefix
CNUM_suffix: $coll_num_suffix
Name: $name
Accession_id: $id
Country: USA
State: California
County: $county
Location: $locality
T/R/Section: $Unified_TRS
Elevation: $elevation
Collector: $assignor
Other_coll: $other_coll
Combined_collector: $combined_collector
Habitat: $ecology
Color: $color
Latitude: $lat
Longitude: $long
Decimal_latitude: $decimal_lat
Decimal_longitude: $decimal_long
Max_error_distance: $extent
Max_error_units: $ExtUnits
Datum: $datum
Source: $source
Notes: $notes
Hybrid_annotation: $hybrid_annotation
USGS_Quadrangle: $quad
EOP

#usually, the blank line is included at the end of the block above
#but since the $ANNO{$id} is printed outside the block, the \n is after
print OUT "$ANNO{$id}\n";

#$notes is currently only used for the pdop conversion
}
foreach(sort {$noname{$a}<=>$noname{$b}}(keys(%noname))){
print "$_ : $noname{$_}\n";
}
foreach(sort(keys(%need_coll))){
print "$_: $need_coll{$_}\n";
}
sub modify_coll_davis {
local($_)=shift;
		s/Andrienne/Adrienne/;
s/Paul Brodmann/Paul Broadmann/;
s/A. Solomechch/A. Solomeshch/;
s/A. T. Wittemore/A. T. Whittemore/;
s/A. M Shapiro/A. M. Shapiro/;
s/BiF Soper/Bif Soper/;
s/Bif Sopez/Bif Soper/;
s/Bijou Dehgan/Bijan Dehgan/;
s/Brian W. Boose./Brian W. Boose/;
s/Charlote Glenn/Charlotte K. Glenn/;
s/Craig Thompson/Craig Thomsen/;
s/Harry Agamelian/Harry Agamalian/;
s/Joe Di Tomaso/Joe Ditomaso/;
s/Joe DiTomaso/Joe Ditomaso/;
s/Joseph Laferriere/Joseph Laferri√®re/;
s/Katherine Countrey/Katherine Courtney/;
s/Katherine Courtny/Katherine Courtney/;
s/Kathi A. Zurakowskai/Kathi A. Zurakowski/;
s/Kathi A. Zukrakowski/Kathi A. Zurakowski/;
s/Kathleen worden/Kathleen Worden/;
s/Kristine L . Preston/Kristine L. Preston/;
s/L. K. Manu/L.K. Mann/;
s/Lurie Oleksiewicz/Laurie Oleksiewicz/;
s/M. Rejmanch/M. Rejmanek/;
s/Maura Cullinare/Maura Cullinane/;
s/Maura Cullinene/Maura Cullinane/;
s/Ralph Philips/Ralph Phillips/;
s/Ramona Robison/Ramona Robinson/;
s/Rex Plamer/Rex Palmer/;
s/Rob Ickel/Rob Ickes/;
s/Susan J. Schmidale/Susan J. Schmickle/;
s/Walter. R Spiver/Walter R. Spiver/;
s/  / /g;
$_;
}
sub log {
print ERR "@_\n";
}
